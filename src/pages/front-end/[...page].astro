---
import Layout from '../../layouts/Layout.astro';
import ResourceFilter from '../../components/ResourceFilter.astro';
import ResourceList from '../../components/ResourceList.astro';
import ResourceTOC from '../../components/ResourceTOC.astro';
import CommentList from '../../components/CommentList.astro';
import { getCollection, getEntry } from 'astro:content';

export async function getStaticPaths({ paginate }: any) {
	const allCategories = (await getCollection('sections')).sort((a, b) => a.data.sortOrder - b.data.sortOrder);
	const resources = (await getCollection('resources', ({data}) => {
		return data.section.slug == 'front-end'; // negative sort orders removes sections altogether
	})).sort((a, b) => new Date(a.data.pubDate).valueOf() - new Date(b.data.pubDate).valueOf()); // ordering by sortOrder asc
	
	// return paginate(resources, {pageSize: 1});

	return allCategories.flatMap( (category: any) => {
		return paginate(resources.filter( (res:any) => (res.data.categories.filter( (cat: any) => cat.slug == category.slug )) ), {
			params: { category: category.slug },
			pageSize: 10
		});
	});
	
	/*
	const allSections = (await getCollection('sections')).sort((a, b) => a.data.sortOrder - b.data.sortOrder);
	const allResources = (
		await getCollection("resources")
	).sort((a, b) => new Date(a.data.pubDate).valueOf() - new Date(b.data.pubDate).valueOf()); // ordering by publication date
	return allSections.flatMap((currentSection: any) => {
		const s = currentSection.slug;
		const filteredResources = allResources.filter((resource: any) => ( resource.data.section.slug === currentSection.slug ));
		//console.log('SECTION = ',currentSection, s, filteredResources, paginate(filteredResources, { params: { id: currentSection.slug }, pageSize: 1}));
		return paginate(filteredResources, {
			params: { section: s },
			props: { currentSection },
			pageSize: 1
		});
	});
	*/
}

console.log(Astro.params, Astro.props);

const { page } = Astro.props;
const currentSection = Astro.url.pathname.split('/')[1];
const section = await getEntry("sections", currentSection);
const { Content } = await section.render();
---

<Layout title="Resurse de Front End Development - Resurse.dev" description="@TODO: scrie descrierea" template="SectionPage">
	<div class="Hero" id="hero">
		<div class="HeroVisual">
			<img class="HeroImage" src={section.data.image?.imageUrl} width="287" height="120" alt={section.data.image?.imageAlt} />
		</div>
		<div class="HeroText">
			<h1 class="HeroTitle">{section.data.title}</h1>
			<details class="HeroDetails">
				<summary class="HeroPreview">
					<p class="HeroP">{section.data.shortDescription}</p>
					<p class="HeroP"><span class="HeroExpand Link" title=`Afișează întreg textul descriptiv pentru resursele de ${section.data.menu}`>Citește mai mult &raquo;</span></p>
				</summary>
				<div class="HeroContent">
					<Content />
				</div>
			</details>
		</div>
	</div>
	<main class="Main">
		<ResourceFilter />
		<ResourceList resources={page.data} page={page} />
		<ResourceTOC section={section} />
		<CommentList />
	</main>
</Layout>